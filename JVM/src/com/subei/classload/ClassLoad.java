package com.subei.classload;

// 1. 加载	jar war jsp 
//	1）通过一个类的全限定名来获取定义此类的二进制字节流
//	2）将二进制字节流代表的静态存储结构转换为方法区的运行时数据
//	3）创建一个java.lang.class对象，作为方法区这个类的各种元数据的访问入口

// 2. 验证：验证class文件是否符合虚拟机的要求
//	1）文件格式验证：例如是否以cafebabe开头，主次版本号是否在范围内，常量池中的常量是否有不支持的类型
//	   该阶段主要是为了保证字节流能正确的转换为方法区的运行时数据。该阶段是基于二进制字节流来进行的，
//	   经过该阶段以后，二进制字节流才转换为方法区的运行时数据，以后的阶段均是基于方法区结构来进行的。
//	2）元数据验证：对字节码描述的信息进行语义分析，例如这个类是否有父类，是否继承了被final修饰的类，
//	  如果这个类不是抽象类，那它是否实现了父类或接口中要求实现的方法，子类是否覆盖了父类的final字段，
//	  是否有不符合要求的方法重载等
//	3）字节码验证：对方法体的代码进行验证，程序逻辑要符合要求，例如保证跳转指令不会跳转到方法体以外的代码
//	  保证方法体中的类型转换是有效的。通过程序去校验程序的逻辑无法做到绝对准确。jdk1.6以后给方法的code属性
//	  增加了stackMapTable属性，其保存了基本块开始时本地变量表和操作栈应用的状态，在字节码验证时，不需要
//	  根据程序代码进行推导，只要验证stackMapTable中的记录是否合法即可。
//	4）符号引用验证：对常量池中的符号引用进行验证，例如通过一个类的全限定名是否可以找到该类

// 3. 准备
//	为类变量分配内存并赋初始值，被static修饰的变量，将在方法区中分配内存，类变量在类初始化的时候
//	在堆中分配内存。这个阶段只赋初始值，static int i = 3,此阶段过后，其值为0，i = 3的putstatic
//	指令，存放于类构造器中

// 4. 解析

// 5. 初始化	有且只有5种情况会触发初始化
//	 执行类构造器的过程，clinit, clinit收集代码中为类变量赋值和static语句块中的代码  （非法向前引用）
public class ClassLoad {

}
